#第一章 要点

## 引言

Django不能扩展的说法并不鲜见，这句话可能完全正确也可能并不全对，取决于你怎么来看待这个问题。Django本身不支持扩展，同样，你也可以这样说Ruby on Rails、Flask、PHP、或者用其他语言编写依赖数据库的动态网站。但是，好消息是，django能够和缓存以及负载均衡工具完美配合，后者能够帮助你扩展来支持众多的流量。可能和你在网上了解到的相反，你不需要替换那些“很慢”的核心组件，比如数据库ORM或者模板系统，就能达到目的。

使用django并且扩展的很成功的案例简直数不胜数，比如，Disqus，Instagram，Pinterest。Instagram使用django仅仅靠3个工程师（其中两个没有任何后端开发经验）就支撑了3千万的用户。Disqus每月的PV量超过80亿。这些网站的流量足够大了，他们证明了使用django是可以扩展的。同样，我们在Lincoln Loop的工作经验也证明这一点。我们用django搭建了一个网站，在Reddit的首页上放了一天，毫不费力。

在扩展的时候，不同的网站会有不同的问题和需要特别关注的痛点。然而，解决这些问题的方法都十分相似，甚至有些关于基础架构的解决方案并不仅仅适用于django。我们使用的技术方案在不同框架和语言间都广泛使用。

我们的观点是：使用django可以扩展。本书讲述的方法会帮助你搭建可以承受日PV百万量级、并发用户数百上千的网站。我们有数年的经验使用这些方法来优化高流量的网站，很有效，我们有信心这些方法对你同样有效。


## 哲学
在Lincoln Loop，我们设计高流量站点的指导性哲学是**简单**。要随时保持警惕避免复杂，否则，很容易就会构建出一个复杂难以维护的庞然大物。

简单意味着：
1. 使用尽量少的组件来完成功能，组件是指机器、服务和第三方软件
2. 选择经过验证的、可靠的组件，而不是最新最热门的
3. 使用经过验证的、可靠的的架构，而不是自己发明
4. 向高效、可扩展和简单的部分倾斜流量

简单的系统易于扩展、理解和开发。当然，每一个网站都必然有其复杂的地方，但是可以尽量其他部分简单，这样你和你的团队可以更多的关注产品本身，而不是基础架构和扩展的问题。


## 痛点
大部分web应用都有共同的性能特征，下面是一些在搭建高性能web应用时经常遇到的痛点，你看到了应该很熟悉。

### 数据库
关系型数据库（比如Postgres或者MySQL）经常是服务栈中最慢最复杂的部分。一个方案是，使用更快更简单的NoSQL数据库，但是这样做的话，往往只是把复杂性推给了你的应用和应用的开发者。我们觉得还是使用一个经过验证的关系型数据库系统简单可靠，然后通过缓存来解决数据库的痛点。

### 模板
模板很容易就搞复杂了，而且更糟的是，django的模板引擎为了简单和可用性牺牲了部分性能。我们可以使用性能更优的模板引擎，比如Jinja2。尽管如此，模板引擎还会是整个服务栈中第二慢的部分。我们也可以通过缓存来解决这个痛点。

### PYTHON
对于很多工作来说，python已经足够快了，而且python还有很成熟的开发工具和生态系统。当然，其他成熟的动态语言也类似。不过我们可以通过web加速器（比如varnish）来缓存请求的响应数据，这样请求根本不用到达python这一层。


## 缓存一切
到目前为止，你可能已经猜到我们准备怎么做了。最简单的方法是，在服务栈的每一层都加上缓存。因为不管你怎么优化你的服务栈，它的效率都不可能比得上独立的缓存。

最理想的是响应数据全部可以通过查缓存得到。如果达不到这种程度，也可以使得尽量多的数据可以通过查缓存得到。数据库层加一个缓存可以极大地减少数据库的访问。

加这么多缓存听起来像是一场噩梦，如果他听过Phil Karlton的一句名言的话：
> 计算机科学领域有两件难事：缓存失效和命名

在下面的章节中，我会教你一些缓存使用技术，用来确保让用户看不到（预期外的）过期数据。另外，我还会介绍如何来调优服务栈，使得即使在缓存失效的时候响应也足够快。

为什么这么急着介绍缓存呢？

多层缓存架构可以让我们用久经考验的高性能的开源工具而不是我们自己构建的复杂系统来应对大量的流量。

负载均衡系统 -> 网站加速器 -> 应用 -> 缓存 -> 数据库

在上述架构的每一层，流量可以水平分发到多个系统。但是流量越往下，系统处理速度越慢，架构上的额外消耗也越多。因此，你的目标是让流量尽可能在上层处理完成。


每一层的可选用的工具有：

 - **负载均衡系统**
   - 开源： HAProxy，Nginx，Varnish
   - 商用： Amazon ELB(Elastic Load Balancer)，Rackspace Cloud Load Balancer
 - **网站加速器**
   - 开源： Varnish，Nginx + Memcached
   - 商用： Fastly，Cloudflare
 - **应用服务器**： uWSGI，Gunicorn，Apache
 - **缓存**： Memcached，Redis
 - **数据库**：Postgres，MySQL/MariaDB 


## 请求处理路径

粗看来，这么多的服务让人觉得恐惧。在我们做咨询的过程中，我们见过有些网站用错了这些基本组件，最终搭建出了一个脆弱不堪的系统。因此，在继续下面的章节之前，弄清楚这些基本组件的作用以及它们之间是怎么相互合作的，这点很重要。

让我们把一条HTTP请求想象成一辆带着数据的车，而你正坐着上面跟着它一起前进。起点是用户的浏览器，用户在浏览器中输入网站地址敲下回车键之后旅程开始了。

首先是一次DNS解析，解析完成之后得到了网站负载均衡系统的IP地址，然后车就上了高速公路朝着这个地址全速前进。


### 负载均衡系统
车的第一站是网站的负载均衡系统，它的作用是把你指向下一个地址。负载均衡系统像一个代理，它收到请求之后会转发给状态健康的下层服务。它有健康检测的功能，会把状态异常的服务摘掉。

大部分的负载均衡系统都会提供几种分发请求的算法供选择，比如轮换调度、最少连接数等。有些也支持权重配置，让服务之间按比例分担流量而不是平均分配。

大部分情况下，轮换调度的方式比较可靠。把流量分配到当前连接数最少的服务听起来很赞，但是在某些情况下会出问题。比如在流量高峰时期增加机器时，新加入机器的连接数会瞬间打满。这会导致新加机器过载，然后导致状态异常而被摘除。

在负载均衡系统这里做SSL转换也不错，在这里把进来的HTTPS请求解密然后以HTTP的形式传往下层服务。在服务栈中，尽早做SSL转换比较好，因为HTTP比较容易处理而且负载均衡系统也有空闲的CPU资源来做这个转换。

有些负载均衡软件和我们下面要介绍的网站加速器可能会有功能上的重复。

### 网站加速器
当你的车通过负载均衡系统之后，它会指引你去到服务栈的下一站：网站加速器。网站加速器（即，带缓存功能的http反向代理）是你可以防止流量继续深入你的服务栈的第一线。在本书中，我们重点关注我们最喜欢的网站加速器：Varnish。

网站加速器的第一个任务是判断一条请求的响应是不是因用户而异的。对于某些应用，每一条请求的响应都是因用户而异的，后面我们会教你一些方法来处理这种情况，但是网站加速器的第一个问题是：这个页面是不是所有用户看到的都一样？

如果响应是用户相关的网站加速器会把你送往下一站，否则它会尝试在它的内部缓存中的查找对应的数据返回给你。如果找到了，你的旅途就此结束了，你会带着一份缓存的数据返回到浏览器中；如果缓存中没有找到对应的数据，网站加速器会把你送往下一站，然后在你返回的时候把你携带的返回数据缓存一份。

最理想的情况是，大部分请求在这里可以处理完。网站加速器可以用来支撑由市场营销活动或者由在Reddit、Facebook之类网站上的病毒性内容带来的突发流量。

不管怎样，你的旅途将继续，下一站：应用服务器。

### 应用服务器
在此之前，你的车在州际高速公路上飞驰，当你开始前往应用服务器的时候，路会变得有点窄了，你的车开始减速了。

应用服务器（我们最喜欢的应用服务器是uWSGI）的任务很简单：把HTTP请求转成python可以理解的WSGI(web server gateway interface)请求。应用服务器内部有很多车道，通过这些车道你能够到达Django服务器。道路现在变成有红绿灯的城市道路了。


### Django应用
Django服务器内部的道路对你来说可能比较熟悉：你需要通过一些中间件，把你的URL交给路由器，它会指引你到应用中特定的事务处理窗口。你会发现这里的Django应用和你自己笔记本上的稍有不同。

有些请求在中间件层就可以获取响应然后返回了，这是Django的站点缓存生效了。当你来到事务处理窗口时，你会发现：有时候不需要请求数据库，有些数据可以通过数据库缓存立即返回；有些内容不需要通过模板引擎处理生成，可以通过模板缓存获得。

尽管和之前几站比起来有点慢，但是django应用的速度也是非常快的。现在你得到了全部的响应数据准备返回了，在你回去的路上你还会通过你来时的每一站，在经过django的站点缓存和网站加速器的时候，它们会缓存一份你携带的响应数据。

你的请求之旅会持续多久呢？所有的这一切将会在几分之一秒的时间内完成。

这里有几个粗略的数据供参考，如果你的应用的响应时间超过这个数值5倍，优化空间将很大：

|预估响应时间|场景|
|10ms | 命中Varnish缓存|
|35ms | 命中Django站点缓存|
|100-300ms| 热缓存Django|
|500ms-2s| 冷缓存Django|

继续细分的话，每个到达django的请求都不能在某一个组件（比如数据库，缓存）上耗时过长，消耗在python代码上的时间不能超过30%，其他组件也一样。

你的Django应用该怎么来衡量性能？是否有优化空间？下一章我们会在讲开发过程的同时告诉你怎么来优化你的服务。
